0189\. 轮转数组
===========

*   标签：数组、数学、双指针
*   难度：中等

[题目链接](#题目链接)
-------------

*   [0189\. 轮转数组 - 力扣](https://leetcode.cn/problems/rotate-array/)

[题目大意](#题目大意)
-------------

**描述** ：给定一个数组 nums，再给定一个数字 k。

**要求** ：将数组中的元素向右移动 k个位置。

**说明** ：

*   使用空间复杂度为 O ( 1 ) 的原地算法解决这个问题。

**示例** ：

* 示例 1：

  ```java
  输入: nums = [1,2,3,4,5,6,7], k = 3
  输出: [5,6,7,1,2,3,4]
  解释:
  向右轮转 1 步: [7,1,2,3,4,5,6]
  向右轮转 2 步: [6,7,1,2,3,4,5]
  向右轮转 3 步: [5,6,7,1,2,3,4]
  ```


  ​                        

*   示例 2：

    ```java
    输入：nums = [-1,-100,3,99], k = 2
    输出：[3,99,-1,-100]
    解释: 
    向右轮转 1 步: [99,-1,-100,3]
    向右轮转 2 步: [3,99,-1,-100]
    ```
    
    
    ​                        

[解题思路](#解题思路)
-------------

### [思路 1： 数组翻转](#思路-1-数组翻转)

先整体翻转，此时数组元素倒置，再以k为界，分别翻转，使得各部分顺序复原

翻转的操作基于对撞双指针实现，时间复杂度为O(N)，本题使用了三个并列的双指针操作，时间复杂度依然为O(N)

可以用一个新数组，先保存原数组的后 k 个元素，再保存原数组的前 n − k个元素。但题目要求不使用额外的数组空间，那么就需要在原数组上做操作。

我们可以先把整个数组翻转一下，这样后半段元素就到了前边，前半段元素就到了后边，只不过元素顺序是反着的。我们再从 k  位置分隔开，将 \[ 0... k − 1 \] 区间上的元素和 \[ k . . . n − 1 \] 区间上的元素再翻转一下，就得到了最终结果。

具体步骤：

1.  将数组 \[ 0 , n − 1 \] \[0, n - 1\] \[ 0 , n − 1 \] 位置上的元素全部翻转。
2.  将数组 \[ 0 , k − 1 \] \[0, k - 1\] \[ 0 , k − 1 \] 位置上的元素进行翻转。
3.  将数组 \[ k , n − 1 \] \[k, n - 1\] \[ k , n − 1 \] 位置上的元素进行翻转。

### [思路 1：代码](#思路-1-代码)

```java
public void rotate(int[] nums, int k) {
        int len = nums.length;
        k %= len;

        reverse(nums, 0, len - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k , len - 1);
    }

    public void reverse(int[] nums, int left, int right) {
        while (left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;

            left++;
            right--;
        }
    }
```


​                            

### [思路 1：复杂度分析](#思路-1-复杂度分析)

*   **时间复杂度** ： O ( n )
*   **空间复杂度** ： O ( 1 )  
