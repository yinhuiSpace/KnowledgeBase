![cover_image](https://mmbiz.qpic.cn/sz_mmbiz_jpg/JHWpHfoC6HrW4D4WUrTH5KLCETkLzFl6sjpMuiaR2tQ4F3l50zfgWsdibm2iaMgFfLWnvHw43ZvMdaEhtAseMoBiag/0?wx_fmt=jpeg)

#  经典的 MySQL 高频面试题



##  ** 基础面试题  **

** 1\.  MySQL  常用的存储引擎有哪些？  **

 InnoDB  和  MyISAM  ，并且能对比分析  InnoDB  和  MyISAM
两种最常用的存储引擎；其他引擎可以自由选择一到三种来回答。回答出来的引擎需要大致知道其特点，比如  Memory
引擎，所有数据都写在内存中，但是只支持表级锁，所以会有较高的读性能，但是写性能会稍差。

** 2\.  InnoDB  引擎和  MyISAM  引擎有什么区别？  **

回答这个问题的关键，是要对  两种索引进行对比分析  ：

  * InnoDB  支持事务，并且通过多版本并发控制（MVCC）来实现高并发性；而  MyISAM  引擎不支持事务，所以  MyISAM  更适用于能承受数据丢失的场景，比如记录操作记录日志等。 

  * InnoDB  支持行级锁，而  MyISAM  只支持表级锁，所以  MyISAM  适合查多写少的场景。 

  * InnoDB  是索引聚集表，索引和数据存储在同一个文件，查询的时候可以直接从叶子节点获取数据；而  MyISAM  索引和数据分开不同的文件进行存储，查询的时候从叶子节点只能获取到磁盘地址，再通过磁盘地址获取数据。 

  * InnoDB  支持外键，  MyISAM  不支持外键。 

** 3\. 为什么  MySQL  不选择使用红黑树来进行存储？  **

实际上有很多面试官喜欢用红黑树来做对比的原因是，红黑树的查询效率很高。但是即便如此，我们依然不会采用红黑树的原因是，红黑树本质上依然是二叉树，也就是每个节点只能存储一个关键字，这样如果数据量比较大会造成这棵树很高，也就是树的深度不可控。

如果碰到这道面试题，那么  我建议大家不要只是回答红黑树，最好能把数组，二叉树，  B  树等都做一个分析对比  ，这样会有一个比较好的加分。

也有一些面试官喜欢问  B  树和  B+  树的区别，实际上本质都是一样的。面试官都是想看看应聘者对这些常用数据结构能不能做一个对比分析，并最后体现出
B+  树的优点，比如查询效率稳定（叶子节点才会存储数据），天然有序，树的深度可控等。

** 4\. 使用自增主键和  uuid  主键或者其他类型主键有什么区别？  **

使用自增主键有一个好处就是自增主键是有序的，而且占用空间小，可以极大提升查询效率和插入数据效率。而如果使用  uuid  或者其他算法产生  id
作为主键，那么因为其本身无需，所以插入数据的时候也更容易造成频繁的页分裂和页合并，而且其占用空间一般也比增主键大的多。但是自增主键也有缺点，那就是主从复制的时候，容易导致主键不一致，这个就需要额外小心，另外就是自增主键也容易被攻击者利用，因为可以猜测出主键，实际业务中其实可以根据业务情况来进行考量选择。

** 5\.  MySQL  中  varchar  和  char  类型有什么区别？  **

char  是定长字符串，最多只能允许  255  长度，如果使用  char
类型，只要定义了长度，即使最终实际数据达不到定义的长度，也会填满指定长度进行存储；  varchar  是变长字符串，实际存储多少就是多少，而且因为
varchar  是变长的，所以还需要使用一个或者两个字节来进行存储长度。

** 6\. 为什么  varchar  经常被定义为  255  长度？  **

这个主要有两个原因：

  * 原因一就是  varchar  是变长字段类型，需要额外存储长度，  255  正好可以一个字节存储，而如果大于  255  则需要使用  2  个字节存储长度； 

  * 另外一个原因就是  MySQL  当中，默认叶子节点只能存储  768  个字节长度的字符串，如果长度大于  768  （使用  utf8  编码，256*3=768，加上长度就会达到 770，大于 768 ），会使用页外存储，这种会触发  DDL  语句的  copy  模式，从而引起锁表，影响写性能。 

** 7\.  varchar  是否有长度限制？  **

在  InnoDB  中，  varchar  最大长度是  65535
，但是实际上能存储的数据会略小于这个值，因为需要额外空间存储长度，而且如果字段允许  null
值，也需要额外空间进行标记，所以很多时候都会被建议尽量不要允许  null  列存在。

** 8\. int(11) 和 int(5) 有什么区别？  **

这道题估计大部分人都认为  int  类型后面的数字代表长度，实际上并不是，不管后面的数字是多少，只要是  int  类型，存储的数据都是一样，为  int
类型所支持的最大长度。实际上这个数字是代表的宽度，比如我们定义了一个 int(5)，但是我们只存入了  1  ，那么实际存储的是  00001
，如果实际存储的数据超过  5  位，那这个宽度就无效了。当然，这个前提也是我们开启了无符号且填充零（UNSIGNED ZEROFILL）时才会进行填充。

** 9\. 为什么  MySQL  在  8.0  版本要删除查询缓存功能？  **

这个主要和  MySQL  的缓存使用规则有关系，  MySQL
的缓存使用非常苛刻，必须要查询语句完全一致才可以使用，哪怕多了一个空格都不行，因为缓存是使用  key-value
进行存储的，而且一旦有更新语句产生，会删除这个表上所有的缓存，所以  MYSQL  缓存的命中率并不高。如果想要使用缓存，  MySQL
官方也是建议放在客户端进行更好，比如我们可以使用  Redis  之类缓存；还有一个原因就是开启查询缓存时，会使用到互斥锁，在高并发场景反而会成为性能瓶颈。

** 10\.  like  语句中  %  和  _  有何区别？  **

在  MySQL  中，这两个符号都表示模糊查询，但是  %  表示 0 个或者多个字符，而  _  仅表示一个字符。

** 11\.  MySQL  中如何处理  count(*)  语句。  **

这道题主要还是对比  MyISAM  引擎和  InnoDB  引擎，  MyISAM  引擎因为维护了一个计数器，所以查询会很快，而  InnoDB
引擎因为存在事务，无法使用计数器，所以会采用扫描辅助索引  B+  树来计数。

** 12\. 谈一下  select  语句的执行过程。  **

一条  select  语句主要会经过以下步骤：

  * 客户端发起一个请求时，首先会建立一个连接。 

  * 服务端会检查缓存，如果命中则直接返回，否则继续后面的步骤（需要开启缓存，而且  8.0  之后版本已经删除缓存）。 

  * 服务器端根据收到的  sql  语句进行解析，然后对其进行词法分析，语法分析以及预处理。 

  * 由优化器生成执行计划，优化器会基于开销选择一个最优执行流程。 

  * 调用存储引擎层  API  来执行查询。 

  * 返回查询到的结果。 

查询过程如下图所示：

﻿

![](https://mmbiz.qpic.cn/sz_mmbiz_png/JHWpHfoC6HrW4D4WUrTH5KLCETkLzFl6YOCVZnbppIw2U7GWUtoOOspC4Nib9J1n7CP4QYYD34WHZsM6JLRh7pg/640?wx_fmt=png&from=appmsg)

  

﻿

##  ** 索引相关面试题  **

索引当中面试题其实重点内容就是  InnoDB  中的聚集索引和非聚集索引，覆盖索引和回表，以及索引在  B+  树中的一些表现。  ** 1\. 谈谈你对
MySQL  中索引的理解。  **
这道题其实是我本人自己在面试的时候比较喜欢问的一道题目，因为索引当中涉及到比较多的知识点，所以我希望通过这道题目看看应聘者能回答到索引的哪些点，也想看下应聘者的逻辑能力，因为一道开放的题目有些人可能一下子不知道如何回答。
正常这道题目思路首先要回答一下索引的作用，然后接下来就需要重点回答一下  InnoDB  中的索引，并且对比  MyISAM
中的索引，像主键索引和非主键索引，覆盖索引，回表等索引相关问题如果都能回答上来会比较有加分。
索引的作用其实就是为了加快查询速度，索引本身就可以理解成一本书籍的目录，通过目录可以找到数据（索引中通过关键字可以找到数据），其他索引相关知识点下面题目还有涉及，这里就不重复介绍。
** 2\.  InnoDB  中的索引和  MyISAM  中的索引有何区别？  **

  * InnoDB  存储引擎是一种索引组织表，其索引和数据存储在一起，叶子节点中直接存储的是整条数据，而  MyISAM  存储引擎中叶子节点存储的是磁盘地址。 
  * InnoDB  中数据和主键索引存储在一起，主键索引也称之为聚簇索引，其余索引称之为非聚簇索引或者辅助索引，二级索引等，其叶子节点存储的是主键值，根据辅助索引查询的时候先根据辅助索引关键字找到主键，再根据主键值去主键索引所在  B+  树中查找数据。 

正常如果回答到这两个面试官可能会打断你，比如会问你辅助索引怎么样可以避免扫描两棵树之类的，或者说避免回表之类的问题，如果没有问，那么我们也可以自己继续回答下面的问题。
** 3\. 什么是回表？如何避免回表？  **
这道题关键是要答出覆盖索引，当我们要查询的数据都在辅助索引中或者根据辅助索引查找对应主键值，这时候就会使用到覆盖索引，也就是不需要回表。因为覆盖索引只需要扫描一颗
B+  树，而且因为辅助索引中不存储整条数据，故整颗树的大小会比主键索引的小，所以如果使用到了覆盖索引查询效率会非常高。  ** 4\.
什么情况下会使用到覆盖索引？  ** 覆盖索引一般会和回表放在一起回答，因为覆盖索引可以避免回表操作，而避免回表操作就是尽量使用覆盖索引。  ** 5\.
辅助索引中为什么存储主键值，而不直接存储主键的数据磁盘地址？因为直接存储数据地址就不需要回表了？  ** 如果大家没有思考过这个问题，可能一下子会被问到。在
InnoDB
存储引擎中是以页为单位的，我们数据都是存储在页中，那么我们思考一下，假如我现在有一页数据刚好满了（实际上不会满，默认有一个负载因子），现在对这条数据进行更新，更新后数据超过
16kb
了，那么这时候这个页肯定存储不下去了，这时候就会发生页的分裂（数据过小也会产生合并），页的分裂和合并是一个相对复杂的过程，我们可以不去讨论，但是页的分裂或者合并必然会带来一个影响就是有一些数据的地址变了，所以这时候如果辅助索引存储的是磁盘地址，那么就需要将涉及到的辅助索引中所有地址都进行更新，这个对性能的影响是很大的，而如果辅助索引存储的是主键值，就很少会有这个问题产生，因为我们一般不会对主键的值进行更新处理。
** 6\. 假如现在有一条  sql  语句查询很慢，这时候我们应该如何去优化？  ** 这道题目很多人一上来就是说加索引，这实际上并不对，因为一条
sql  语句执行慢有很多原因，也有可能用到了索引但是依然很慢，所以我们第一步一定是通过  explain  关键字来查看下  sql
语句的执行计划，并针对执行计划来有针对性的进行分析。

  * 假如确实没有使用到索引。那么这时候我们可以看看表中有没有现成的索引，有的话看下是否合适拿来用，没有的话那就可以尝试建立合适的索引。假如没有使用到索引但是当前查询条件的列上又有索引，那就要分析下为什么不走索引，是不是因为离散度太低，是不是用到了范围查询，是不是对索引列使用了函数等。 
  * 假如使用到了索引。使用到了索引依然很慢，这时候可以分析看看是否可以使用其他更合适的索引，也可以考虑下能不能使用到覆盖索引呢？能不能使用到索引下推等索引支持的优化措施呢？这些都可以尝试用来进行调优处理。 
  * 如果索引优化措施全部用上了还是很慢，那么其他思路就是需要从业务上去考虑。比如可以思考原有的表设计是否正常？是否可以考虑字段冗余来减少关联查询或者嵌套查询等，或者说将数据量较大的表进行汇总到历史表，或者说查询的时候禁止深度分页等等措施。 
  * 当然也要考虑下操作系统的硬件影响，是不是当前服务器就是已经到瓶颈了等等。 

** 7\. 哪些场景下会导致  MySQL  不走索引？  ** 回答这道题前，我们需要明确一点那就是  MySQL
是基于开销的查询，而不是基于规则，也就是所有的规则都不是万能的，我们只能根据经验去判断一些大概率不走索引的场景。比如以下场景：

  * 在索引列上使用函数  replace\substr\concat\sum count avg  等，使用表达式或者计算（+、-、*、/）。 
  * 字符串不加引号，会出现隐式转换，相当于使用函数 to_char()。 
  * 使用  !,<>,not like,not in  等反向查询。 

** 8\. 什么是索引的最左匹配原则？  ** MySQL
的最左匹配原则可以分为单列索引和多列索引两种场景。单列索引指的是搜索关键字从最左边开始逐个匹配，因为只有左边的值确定了才可以在  B+
树中进行搜索，而如果左边的值不确定，比如使用了  %  等，那么搜索的时候在  B+
树中无法知道到底是走哪条路，从而会导致全表扫描；多列索引指的是多列组成的索引中，是从第一个字段开始搜索的，如果第二个字段不明确，那么就会导致后面的字段都不会使用到索引。
** 9\. 索引下推指的是什么？谈谈你的理解。  ** 索引下推是  MySQL  自身支持的一种优化措施，指的是原本需要将数据返回到  Server
层进行过滤的操作在存储引擎层就完成了，这样可以避免大量回表的产生。  ** 10\. 既然  MySQL
会触发索引合并优化方案，那我们是不是可以尽量创建更多的单列索引来触发索引合并从而提升提升效率？  **
其实如果触发了索引合并，只能说索引建的不够好或者表设计不够好，索引合并也并不是说合并的索引越多越好，因为一个索引就是一颗树，也就是会导致扫描多颗树，这种情况如果使用一个联合索引效率会更高。再者，一个表当中，并不是索引越多越好，索引越多意味着表总共占用的空间也更大，每次更新数据也需要维护更多的索引，影响写数据性能。
** 11\. 不考虑覆盖索引的情况，唯一索引和普通索引谁的效率高，为什么？  **
在查询时，唯一索引一般会比普通索引快，因为唯一索引的查询会在命中一条数据后就直接返回，不需要继续扫描后面的数据，而普通索引，如果不加  limit 1
限制，那么即使查询到数据，还需要继续扫描后面的数据，直到扫描的不符合条件的数据才会停止扫描。  在更新时，普通索引可以直接在缓存（  change
buffer  ）中完成即可返回更新成功，而唯一索引则不行，其必须要对其他数据进行检测，确保没有数据冲突，所以更新时唯一索引可能会更慢。  ** 12\.
InnoDB  是索引组织表，那如果表里没有主键怎么办？  ** 如果没有主键，那么  MySQL
会寻找有没有唯一索引，如果有会将唯一索引作为主键来组织数据，如果没有唯一索引，那么  MySQL  就会创建隐藏主键  rowid  来组织数据。

##  ** 事务和锁相关面试题  **

事务的重点首先事务的四大特性那是需要条件反射都能回答的，然后重点就是  MVCC  的实现，四种隔离级别以及其分别会带来哪些问题，锁的实现，以及为什么
InnoDB  能解决幻读问题。  ** 1\. 谈谈  MySQL  中事务的四大特性。  ** 事务
的四大特性主要就是：原子性，一致性，隔离性，持久性。然后分别大致说一下这四大特性的特点，这个问题本身并不难，问这个问题更大的概率其实是为了引出隔离性，回答这个问题的同时我们也可以将四种隔离级别也一并回答。
** 2\.  MySQL  中的事务支持哪些隔离级别，并谈谈你的理解。  ** 在  InnoDB
中（如果面试官没有提及，最好我们主动提一下这四种隔离级别是在  InnoDB  引擎实现的），对  SQL 92
标准的四种隔离级别都支持，并在四种隔离级别的标准上解决了幻读问题。

  * 未提交读（RU）：指的一个事务能看到另一个事务未提交的事务，这是最低的隔离级别，会产生脏读问题（比如事务 1 没提交，被事务 2 查询出来之后，事务 1 又进行了回滚）。 
  * 已提交度（RC）：指的是一个事务当中每次查询都能看到另一个已提交事务的最新信息，这种就会产生不可重复读问题（比如事务 1 第一次查询时事务 2 没提交，这时候查不到未提交数据，岁后事务 1 又进行了一次查询，而恰好这时会后事务 2 已经提交了，这时候事务 1 就能查询到已提交数据，导致一个事务中前后两次查询结果不一致）。 
  * 可重复读（RR）：可重复读通过  MVCC  机制解决了不可重复读的问题，并且在  InnoDB  中在可重复读的隔离级别之下还通过锁解决了幻读问题。 
  * 串行化：最高级别，所有事务串行执行，效率极低。 

** 3\. 谈谈  MVCC  具体是如何执行的。  ** MVCC（Multi Version Concurrency
Control），多版本的并发控制。当修改数据的时候，可以为这条数据创建一个快照，后面就可以直接读取这个快照。  在  InnoDB  中，为了实现
MVCC  机制，其内部为每一行添加了两个隐藏列：  DB_TRX_ID  和  DB_ROLL_PTR  。

  * DB_TRX_ID：事务  ID  ,长度为  6  字节，用来存储插入或更新语句的最后一个事务的事务  ID  。 
  * DB_ROLL_PTR：回滚指针，长度为  7  字节。回滚指针指向写入回滚段（undo log）的记录，读取记录的时候会根据指针去寻找  undo  段中的记录。 

当我们在一个事务中进行了第一次查询之后或者手动开启视图，这时候就会产生一个视图，后续就会根据以下规则进行查询来保证可重复读：

  * 以当前事务创建视图的时刻为准，如果一条数据的事务版本是在当前事务创建视图之前生成并提交的，可见。 
  * 如果一条数据的事务版本是在当前事务创建视图之后才生成的，不可见。 
  * 假如一条数据的事务版本是在当前事务创建视图之前创建的，但是在视图创建之后才提交，不可见。 

** 4\.  InnoDB  中是如何解决幻读问题的？  ** 在  InnoDB
中行锁有三种算法：记录锁，间隙锁，临键锁。临键锁默认是左开右闭区间，使用临键锁时，会锁住了当前记录的下一个不匹配的主键值，可以防止当前命中值和下一个未命中值这个区间范围内插入数据，从而解决了幻读问题。
** 5\. 什么是乐观锁和悲观锁？  **
乐观锁和悲观锁其实和数据库当中本身提供的锁并不是同一种概念，悲观和乐观的概念是两种锁的思想。悲观锁指的是不管什么操作，我就认为此次操作可能会存在并发问题，所以直接加锁处理；而乐观锁的意思就是我认为此次操作可能并不会存在并发问题，所以不会直接加锁，而是在正式提交数据的时候再做一次检测，如果发现冲突则返回冲突信息，如果未发生冲突则直接进行处理。乐观锁的实现方式不同场景有不同的实现方式，比如可以通过为每条数据新增版本号，每次提交时检测版本号，版本号一致则认为无冲突。
** 6\. 自增主键用完了会怎么样？  **
这道题目其实很简单，但是如果大家平常没留意的话可能会一下子不知道怎么回答。主键用完之后如果继续插入数据，那么主键不会继续递增，所以会报主键冲突（不考虑数据被删除情况），这道题目记住即可。
** 7\. 自增主键是否一定连续？  ** 自增主键不一定会连续，主要有三个原因：

  * 唯一约束或者外键约束冲突等异常导致事务回滚，此时主键已经被自增，但是数据却回滚了。 
  * 当无法计算一次性会插入多少数据（如使用  insert/replace...select  等语句）时，会预先申请多余主键，此时插入的数据可能用不完申请下来的所有主键。 
  * 当修改了  auto_increment_increment  变量时，可以让主键并不是按  1  递增。 

** 8\. 谈谈  redo log  和  binlog  的理解。  **

  * redo log  是  InnoDB  引擎特有的，而  binlog  是  MySQL  的  Server  层实现的，所有引擎都可以使用。 
  * redo log  是物理日志，记录的是“在某个数据页上做了什么修改”，而  binlog  是逻辑日志，记录的是这个语句的原始逻辑，比如“给  id=2  这一行的  c  字段加  1  ”。 
  * redo log  是循环写的，空间固定会用完，而  binlog  是可以追加写入的。“追加写”是指  binlog  文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 
  * redo log  主要用于崩溃修复，而  bin log  属于归档日志，主要用户备份和数据还原。 

** 9\. 什么是  2pc  ，谈谈  2pc  在  MySQL  中的应用。  ** 2pc  指的是二阶段提交，  3pc  指的是三阶段提交，
MySQL  在更新语句的时候，对  redo log  和  binlog  采用了二阶段提交法的思想。

  * 二阶段提交法：主要是有一个事务协调者，先发起一个  prepare  请求，这时候所有的参与者收到请求之后会处理事务，但不进行提交，处理完事务之后需要对  prepare  请求做出响应；事务协调者收到所有事务参与者的响应之后，则会再次发起  commit  请求，事务参与者收到  commit  请求之后进行事务提交，提交之后对事务系统协调者做出响应。 
  * 二阶段提交法存在明显的两个问题：一个就是单个事务参与者处理失败或者没有给事务协调者响应，会造成事务整体事务失败；另一个就是如果事务协调者出现宕机等问题，会导致所有事务参与者阻塞等待指令，可能需要人工进行数据修复。 
  * 三阶段提交法解决了二阶段提交法的阻塞问题，新增了超时机制。三阶段提交法分为了三个阶段：  CanCommit  阶段，  PreCommit  阶段，  DoCommit  阶段。 

CanCommit  阶段：类似于二阶段提交法的  prepare  请求，指的是事务协调者向所有事务参与者发起一个  CanCommit
请求，事务参与者收到请求后，不做任何操作，仅作预估判断，如果可以提交事务返回  Yes  ，否则返回  No  。  PreCommit
阶段：(1)、假如收到  CanCommit  的所有响应都是  Yes  ，协调者会再次发送  PreCommit  请求，事务协调者收到
PreCommit  请求之后会执行事务操作，但不提交，执行事务操作完成之后返回  Ack  响应。；(2)、如果有部分事务参参与者未返回  Yes
，而是返回了其他响应，或者响应超时，那么事务协调者会取消事务；  DoCommit  阶段：(1)、假如  PreCommit
阶段部分节点未返回正确响应，那么事务协调者会中断整个事务；(2)、假如部分事务参与者超时为返回响应，那么整个事务依然会被提交，所以这一步可能会造成各个事务参与者数据不一致问题；(3)、假如所有节点都返回了正确响应，那么整个事务提交成功。

  * 三阶段提交法会更复杂，而且  PreCommit  阶段有超时问题产生时，会造成数据不一致问题，在实际场景中，二阶段提交法相比较三阶段提交法更简单，而且出现数据问题之后也会比较容易处理，所以应用还是会更广泛。 

** 10\. 谈谈  MySQL  中的日志先行（  WAL  ）。  ** 这个主要就是当  MySQL
在更新数据时，不会直接写入磁盘，而是直接写日志，然后再写入数据磁盘。虽然说日志也在磁盘中，但是写入日志磁盘是顺序  IO  ，而直接写入数据磁盘那就是随机
IO  ，这两者的效率也是相差非常大的。  



